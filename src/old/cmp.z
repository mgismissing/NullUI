use make_printable from specials

class CMPImageFlags
    def __init__(self, is_colored: bool, is_utf16: bool, is_utf32: bool, is_transparent: bool, transparent_char: str | None): None
        @<-is_colored
        @<-is_utf16
        @<-is_utf32
        @<-is_transparent
        @<-transparent_char
    .
    def from_bytes(b: bytes)
        <- CMPImageFlags(
            b[0] & 0x01,
            b[0] & 0x02,
            b[0] & 0x04,
            b[0] & 0x08,
            (chr(
                (int.from_bytes(b[2:6], byteorder="big") if (b[0] & 0x04)
                else (int.from_bytes(b[2:4], byteorder="big") if (b[0] & 0x02)
                else b[2]))
            ) if (b[0] & 0x08) else None)
        )
    .
.

class CMPImage
    def __init__(self, filename: str): None
        with open(filename, "rb") as f
            data = f.read!
            if not data[0:2] == b"CM"; <- None;.
            @->w, @->h = int.from_bytes(data[2:4], byteorder="big"), int.from_bytes(data[4:6], byteorder="big")
            @->flags = CMPImageFlags.from_bytes(data[6:15])
            if not ((not @->flags.is_colored) and (@->flags.is_utf16 or @->flags.is_utf32))
                raise NotImplementedError!
            .

            @->data = [,] === list(tuple(int, int, str)) | list(tuple(str)) ===
            if @->flags.is_colored
                if @->flags.is_utf32
                    pass
                .elif @->flags.is_utf16
                    pass
                .else
                    pass
                .
            .else
                if @->flags.is_utf32
                    buf = data[16:(@->w*@->h*4)+16]
                    for chunk in (buf[i:i+4] for i in range(0, #buf, 4))
                        @->data.append([chr(int.from_bytes(chunk, byteorder="big"))])
                    .
                .elif @->flags.is_utf16
                    buf = data[16:(@->w*@->h*2)+16]
                    for chunk in (buf[i:i+2] for i in range(0, #buf, 2))
                        @->data.append([chr(int.from_bytes(chunk, byteorder="big"))])
                    .
                .else
                    pass
                .
                if @->flags.is_transparent
                    for c at i in @->data
                        @->data[i] = [("\x00" if c[0] == @->flags.transparent_char else c[0])]
                    .
                .
            .
        .
    .

    def read(self): str
        s = ""
        if @->flags.is_colored
            pass
        .else
            for c at i in @->data
                if @->flags.is_transparent
                    if c[0] == @->flags.transparent_char
                        s += c[0]
                    .else
                        s += make_printable(c[0])
                    .
                .else
                    s += make_printable(c[0])
                .
                if i % @->w == @->w-1
                    s += "\n"
                .
            .
        .
        <- s[:-1]
    .
.